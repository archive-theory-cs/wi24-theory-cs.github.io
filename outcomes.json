{
    "Communication": {
        "Description": "Clearly and unambiguously communicate computational ideas using appropriate formalism. Translate across levels of abstraction.",
        "Icon": "<i class='bx bxs-message-square-edit'></i>",
        "Children": {
            "Classify languages": {
                "Description": "Classify the computational complexity of a set of strings.",
                "Children": {
                    "Classify language": {
                        "Description": "Classify the computational complexity of a set of strings by determining whether it is regular, context-free, decidable, or undecidable."
                    },
                    "Find example languages": {
                        "Description": "Give examples of sets that are regular, context-free, decidable, or undecidable languages (and prove them)."
                    }
                },
                "Icon": "CL",
                "file": "classifylanguages.html"
            },
            "Decision problems": {
                "Description": "Classify the computational complexity of a decision problem by translating it to a set of strings coding the problem.",
                "Children": {
                    "Define decision problem": {
                        "Description": "Translate a decision problem to a set of strings coding the problem."
                    },
                    "Classify decision problem": {
                        "Description": "Classify computational complexity of a decision problem."
                    }
                },
                "Icon": "DP",
                "file": "decisionproblems.html"
            },
            "Automata": {
                "Description": "Use and design automata both formally and informally, including DFA, NFA, PDA, TM.",
                "Children": {
                    "Formal definition of automata": {
                        "Description": "Use precise notation to formally define the state diagram of DFA, NFA, PDA, TM."
                    },
                    "Informal definition of automata": {
                        "Description": "Use clear English to describe computations of DFA, NFA, PDA, TM informally."
                    }
                },
                "Icon": "A",
                "file": "automata.html"
            },
            "Other Models of Computation": {
                "Description": "Describe and use models of computation that don't involve state machines.",
                "Children": {
                    "Regular expressions": {
                        "Description": "Use regular expressions and relate them to languages and automata."
                    },
                    "Context-free grammars": {
                        "Description": "Use context-free grammars and relate them to languages and pushdown automata."
                    }
                },
                "Icon": "M",
                "file": "models.html"
            }
        }
    }
    ,
    "Problem Solving": {
        "Description": "Know, select and apply appropriate computing knowledge and problem-solving techniques. Reason about computation and systems. Use mathematical techniques to solve problems. Determine appropriate conceptual tools to apply to new situations. Know when tools do not apply and try different approaches. Critically analyze and evaluate candidate solutions.",
        "Icon": "<i class='bx bxs-bulb' ></i>",
        "Children": {
            "Computability techniques": {
                "Description": "Apply classical techniques including pumping lemma, determinization, diagonalization, and reduction to analyze the complexity of languages and problems.",
                "Children": {
                    "Pumping Lemma": {
                        "Description": "Use the pumping lemma to prove that a given language is not regular."
                    },
                    "Diagonalization": {
                        "Description": "Use diagonalization to prove that there are 'hard' languages relative to certain models of computation."
                    },
                    "Reduction": {
                        "Description": "Use appropriate reduction (e.g. mapping, Turing, polynomial-time) to deduce the complexity of a language by comparing to the complexity of another."
                    }
                },
                "Icon": "CT",
                "file": "apply.html"
            }
        }
    },
    "Modeling and Impact": {
        "Description": "Understand, guide, shape impact of computing on society/the world. Connect the role of Theory CS classes to other applications (in undergraduate CS curriculum and beyond). Model problems using appropriate mathematical concepts.",
        "Icon": "<i class='bx bxs-paper-plane'></i>",
        "Children": {
            "Calibrate difficulty": {
                "Description": "Prove that certain models of computation are equivalent and translate between them algorithmically.",
                "Children": {
                    "Nondeterminism": {
                        "Description": "Explain nondeterminism and describe tools for simulating it with deterministic computation."
                    },
                    "Church-Turing": {
                        "Description": "Explain the Church-Turing thesis and use it to operationalize the notion of algorithm."
                    }
                },
                "Icon": "Cal",
                "file": "calibrate.html"
            }
        }
    }
}